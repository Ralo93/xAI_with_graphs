import numpy as np
import torch
from torch_geometric.nn import GCNConv
from torch.nn import Linear, Dropout, ReLU
from torch_geometric.datasets import Planetoid
from torch_geometric.explain import Explainer, GNNExplainer
import networkx as nx
import matplotlib.pyplot as plt
from pyvis.network import Network

class GCN(torch.nn.Module):
    def __init__(self, c_in, c_out, c_hidden):
        super().__init__()
        torch.manual_seed(12345)
        self.conv1 = GCNConv(c_in, c_hidden)
        self.conv2 = GCNConv(c_hidden, c_out)
        self.dropout = Dropout(p=0.5, inplace=False)

    def forward(self, x, edge_index):
        x = self.conv1(x, edge_index)
        x = ReLU()(x)
        x = self.dropout(x)
        return self.conv2(x, edge_index)

# Load dataset
dataset = Planetoid(root='data/Planetoid', name='Cora')
data = dataset[0]

# Train the GCN
c_in = dataset.num_features
c_out = dataset.num_classes
gcn_model = GCN(c_in=c_in, c_out=c_out, c_hidden=16)
loss_function = torch.nn.CrossEntropyLoss()  # Define loss function
optimizer = torch.optim.Adam(gcn_model.parameters(), lr=0.01, weight_decay=5e-4)  # Define optimizer

def train():
    gcn_model.train()
    optimizer.zero_grad()  # Clear gradients
    out = gcn_model(data.x, data.edge_index)  # Perform a single forward pass
    loss = loss_function(out[data.train_mask], data.y[data.train_mask])  # Compute the loss solely based on the training nodes
    loss.backward()  # Derive gradients
    optimizer.step()  # Update parameters based on gradients
    return loss

def test(mask):
    gcn_model.eval()  # Set model to evaluation mode
    out = gcn_model(data.x, data.edge_index)
    pred = out.argmax(dim=1)  # Use the class with the highest probability      
    correct = pred[mask] == data.y[mask]  # Check against ground-truth labels
    acc = int(correct.sum()) / int(mask.sum())  # Derive ratio of correct predictions
    return acc

# Training loop
for epoch in range(1, 201):
    train()
    train_acc = test(data.train_mask)
    val_acc = test(data.val_mask)
    test_acc = test(data.test_mask)
    print(
        f'Epoch: {epoch:03d}, Train acc: {train_acc:.4f}, '
        f'Val acc: {val_acc:.4f}, Test acc: {test_acc:.4f}'
    )

# Initialize the GNNExplainer and Explainer
explainer = Explainer(
    model=gcn_model, 
    algorithm=GNNExplainer(epochs=200), 
    explanation_type='model',
    node_mask_type='attributes',
    edge_mask_type='object',
    model_config=dict(
        mode='multiclass_classification', 
        task_level='node', 
        return_type='log_probs'
    )
)

# Choose a node to explain (e.g., node index 10)
node_idx = 10

# Generate the explanation for the node (node explanation)
explanation = explainer(data.x, data.edge_index, index=node_idx)

# Check available explanations
print(f'Generated explanations in {explanation.available_explanations}')

#Visualize with pyvis
def visualize_explanation_subgraph_with_pyvis(explanation, node_idx, data, threshold=0.5):
    """
    Visualize the subgraph explanation using Pyvis.
    
    Args:
        explanation: The explanation object with edge and node masks.
        node_idx: The index of the node being explained.
        data: The original graph data object.
        threshold: Importance score threshold for selecting edges (default is 0.5).
    """
    # Extract edge mask and important edges
    edge_mask = explanation.edge_mask  # Edge importance scores
    edge_index = data.edge_index.cpu().numpy()

    # Filter edges with high importance
    important_edges = edge_index[:, edge_mask > threshold]

    # Create a Pyvis Network graph
    net = Network(notebook=True)  # Use `notebook=False` if running in a script
    net.set_options("""
    var options = {
      "physics": {
        "forceAtlas2Based": {
          "gravitationalConstant": -50,
          "centralGravity": 0.01,
          "springLength": 100,
          "springConstant": 0.08
        },
        "minVelocity": 0.75,
        "solver": "forceAtlas2Based"
      }
    }
    """)

    # Add nodes
    node_set = set(important_edges.flatten())
    for node in node_set:
        net.add_node(int(node), label=str(int(node)), title=f"Node {int(node)}")

    # Add edges
    for edge in important_edges.T:
        net.add_edge(int(edge[0]), int(edge[1]))

    # Save and show the graph
    html_path = f"subgraph_node_{node_idx}.html"
    net.show(html_path)
    print(f"Subgraph visualization saved as {html_path}. Open it in your browser.")

# Call the function
visualize_explanation_subgraph_with_pyvis(explanation, node_idx, data)